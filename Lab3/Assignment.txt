1. I created 4 processes. The first process runs the find command. The second process runs the grep. The third process runs the sort command. The final proccess runs the head command. There are three pipes needed to run the commands. The pipes are needed for the first to second processes, second to third processes, and third to fourth processes. The first three processes pipe the results into the pipe. The last three processes then read the pipe of the results from the previous process.

2. I had problems with closing the pipes. The pipes were not being closed correcltly. I was closing the pipes below the execl statement. I moved the close statements to above it, which resulted in the correct output. This was the result of the execution not seeing the pipes closed, so it would just hang and not appear to do anything.

3. Pipes contribute to this philosophy because it sends text streams to the next process. This makes it easy to read in and out from when writing programs. They also allow programs to be able to work together because pipes allow communication between them. I think this is good philosophy for software engineering because it modularizes the approach and makes adding things easier for developers.
